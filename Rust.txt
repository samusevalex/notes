	Основные ошибки RAM (Википедия memory safety):
1. buffer overflow read/write - чтение/запись за границей, например, массива
2. race condition - чтение/запись из shared memory в concurrent системах
3. null pointer dereference - указатель в пустую/левую память
	use after free
	use of uninitialized memory
4. illegal free уже удалённого pointer-а или non-memory-alloced pointer
	double free - вызвали free(p), потом OS эту память кому-нибудь отдала, а мы опять вызвали free(p)
	invalid free - взяли р = random() и сделали free(p)
5. stack/heap exhaustion = stack overflow/out-of-memory error

http://www.youtube.com/watch?v=VJNFPty55ac доклад Rust вместо С++

Архитектура программ: 
1. Суперцикл - один большой main
2. Событийное управление - работает по прерываниям. Пишем 10 классов и каждый из них запускается только при получении прерывания. ~ int 10h будет передавать управление классу №7.
3. Диспечеризация - есть один класс, который слушает прерывания/события и в зависимости "от" выставляет Flag. Есть второй класс, который крутит цикл, но в цикле не всё подряд, как в случае 1, а только проверка флагов и в зависимости "от" запускает соответствующий класс.

Сильная статическая типизация. Rust безопасный т.к. мощный статический анализ.

Компилируется только в LLVM ~ как компилятор Сlang
Строгий компилятор как у Haskel. Если скомпилировалось, то работает.

Cargo - пакетный менеджер в Rust. Умеет всё: компилирует(cargo build), тестирует(cargo test), добавляет зависимости (подключает сторонние библиотеки), запуск проекта (cargo run), генерация документации (cargo doc), форматирование кода (cargo fmt). В Cargo продуманная система организации проекта. Нет никаких .h, никаких #include. Само организуется в систему пакетов и модулей.

Вроде как есть аналог Exception ? называется Panic. Если к 255 прибавить 1, то программа перейдёт в блок кода, называемым Panic.

"Жирные" указатели на массив. В С++ указатель int *p = new int[10] содержит только адрес начала массива ? можно вылезти за границу, т.е. обратиться к элементу 11. В Rust указатель на массив - это адрес начала + длина. Если вылазим за пределы массива ? Panic.

	Перед использованием переменная обязательно должна быть инициализированна. Или компилятор выдаст Error.
	Нельзя u8 + i32 т.к. непонятно что будет с битностью и знаковостью результата. Ручками делаем явное приведение типов.
	Все переменные по default-у const. Т.е. let a = 10. Для того чтобы из этого сделать "нормальную" переменную надо let mut a = 10
	Бинарная совместимость с С++. Из С++ можем спокойно вызывать код на Rust и наоборот
	Нет GC и Runtime (как-то может работать без стандартной библиотеки)
	Если что-то не получается написать в жёсткой системе Rust, можно создавать unsafe блоки, в которых проверка кода на происходит.
	С объектом автоматически делается free(), когда выходим за scope или нет ссылок (ref counter).
	В Rust нет Null. Тот кто ввёл понятие Null потом сказал, что это была ошибка на миллиард $.
Option<T> и Result<T, E> - какие-то типы, находящиеся в Core, для обработки ошибок. В Rust  отказались от исключений в пользу Result.
	Core - тут сидят основные языковые структуры, типы данных, Option, Result, Iterators, полиморфизм, дженерики, прямой доступ к памяти (mem, ptr).
	Std - стандартная библиотека. Если работаем с микроконтроллерами, там нет операционной системы, то Std не нужно. В Std сидит: println(), потоки (thread, mpsc), динамическое выделене памяти, коллекции (HashMap и т.п.), сокеты (модуль net)...
	Heapless колекции - работают на буферах вместо кучи. Бывают микроконтроллеры без Heap-а, только Stack.
	Про Concurrency: компилятор гарантирует, что у нашей переменной либо много читателей (aliasing), либо один писатель (mutability). Много писателей - это mpsc очереди.

	В Эльбрусе Pointer/Descriptor (128 бит) = base address + длина/размер окна + текущее положение в этом окне.
	В Эльбрусе Бабаян ввёл понятие "Контекстная защита/целостность" - в Си есть правило видимости. Если мы зашли в функцию, то видим global/local переменные + args, которые передаём в функцию. Задача: если мы получили Pointer на функцию, зашли в неё, то из этой функции мы не можем получить доступ к чему-либо за пределами видимости. Если функция создала объект на стеке, то время жизни этого объекта = времени жизни функции. Функция закончилась, и даже если где-то сохранился Pointer на объект на стеке, то Pointer станет "invaild". Эльбрус гарантирует, что если мы имеем Pointer на абы куда, то этот Pointer - valid, т.е. по нему есть "живой" объект и этот объект принадлежит нам! А не как в случае с вирусами получаем Pointer на "чужой" объект. Решает проблему выхода за границы массива. + Решает проблему сборки мусора.
Также в Эльбрусе есть механизмы диспечеризации неинициализированной памяти ~ Valgrind (~qemu эмулирует CPU, в нём запускаем нашу программу. Состоит из нескольких модулей: Memcheck - позволяет обнаруживать ошибки утечки памяти, read/write за пределами выделенных регионов; Cachegrind - собирает статистику по cache miss, branch prediction, PreFetch и т.п.), Address Sanitizer, Memory Sanitizer.

В Rust помимо типа у переменной есть атрибуты:
	- borrowing	заимствование данных
	- owner		кто владеет нашей переменной/struct
	- lifetime		время жизни, защищает от таких вещей как:
			Куда-то передали Pointer на массив. Массив удалили. В Си Pointer можно использовать. Переходим по Pointer-у - получаем ошибку. Rust благодаря lifetime подобных ошибок избегает.
			Есть функция, которая возвращает ссылку на свою внутреннюю локальную переменную. В Си всё скомпилировалось и будет ошибка. В Rust благодаря lifetime-ам...
			Функция в качестве аргументов принимает 2-е ссылки на String и возвращает ссылку на одну из них. В Rust будет ошибка, т.к. компилятор не сможет определить lifetime для return &String. Необходимо ручками как-то переопределить этот lifetime.
