Основные ошибки RAM (Википедия memory safety):
1. buffer overflow read/write - чтение/запись за границей, например, массива
2. race condition - чтение/запись из shared memory в concurrent системах
3. null pointer dereference - указатель в пустую/левую память
	use after free
	use of uninitialized memory
4. illegal free уже удалённого pointer-а или non-memory-alloced pointer
	double free - вызвали free(p), потом OS эту память кому-нибудь отдала, а мы опять вызвали free(p)
	invalid free - взяли р = random() и сделали free(p)
5. stack/heap exhaustion = stack overflow/out-of-memory error

Ошибки переполнения: int (8 бит) 250+125 - что делать?

https://www.youtube.com/watch?v=Cg7geUDHH4A
Coq - для Формальной Верификации, интерактивная оболочка для доказательства теорем. Под капотом жёстко типизированный функциональный язык Gallina. Берём, допустим, компилятор и, используя Coq, доказываем, что он правильно переводит некую функцию из Языка №1(С++) в Язык №2(asm).
Большинство ошибок в Оптимизаторах.
Код можно обкладывать Unit-тестами. Но Unit-тестами всё равно не покроешь все возможные Input значения. Coq позволяет это сделать, но строк кода будет раз в 10 больше, чем в "тестируемой" программе.

http://www.youtube.com/watch?v=2KI5JyAX15E Ермаков Илья
http://iermakov.ru - Оберон: семейство языков

Классический Oberon-07 (в 2007 году Вирт ввёл координальные изменения)
Вторая ветка развития: Active Oberon - для concurrency. Операционная Сиситема - А2. Работа в едином адресном пространстве.
Третья ветка: Оберон/Оберон-2/Component Pascal - Компонентно-Ориентированное Программирование.

В 50-х языки высокого уровня Fortran, Cobol, Lisp, Algol60 вместо чисто машинного кода.
В 60-х структурное программирование. Программа состоит из иерархической структуры подпрограмм, без GOTO (статья Эдсгера Дейкстры) только последовательность, ветвление, цикл - Pascal.
В 80-е объектно-ориентированное программирование (изобретенном еще в 60-х гг. в алголоподобном языке Симула-67).
В 90-е компонентно-ориентированное программирование должно решить проблемы ООП, в частности, бесконтрольное использование ООП приводит к проблемам с надежностью больших программ.

КОП = ООП
+ модульность. Включая скрытие информации и позднее связывание модулей, т.е. возможность подгружать необходимые модули в процессе выполнения программы, а не заранее, как это обычно делается в старых системах программирования.
+ безопасность. Статический контроль типов переменных и автоматическое управление памятью.
- наследование. Реализации через границы модулей.

1. Oberon - хорошая замена Си для микроконтроллеров.
2. Компилятор для Oberon может написать и студент.
3. Строго детерминирован. Мы пишем конструкцию и точно знаем во что она развернётся на CPU - можно использовать для систем с жестким реальным временем. Как правило чем более высокоуровневей язык, тем менее детерминирован. В Java не всегда понятно что будет на ассемблере.
4. Сверхкомпактный - описание на 16 страницах + 23 страницы про многопоточный Оберон (Active Oberon). ОС для Active Oberon - А2.
5. Модульный - можно всё представлять в виде классов, а можно в виде модулей. 1000 модулей живёт в одном адресном пространстве. Можно наоборот всё это дело делить на микросервисы и гонять между ними сообщения.
6. Строго статически типизированный.
7. Нельзя разрушить память, если не использовать специальные средства для прямого доступа в память. Память защищена языковыми средствами.
8. Есть необязательная сборка мусора. Можно вкл., можно выкл. Для Real-Time соответственно выкл.
9. В "небезопасном" Си класическая уязвимость - переполнение буффера = вылезаем на пределы массива. В "безопасных" языках типа Java, Oberon есть встроенная verification.
10. Универсальные языки типа Си слишком "близки к машине". Но как правило для прогера быстродействие неважно, хотят максимальные абстракции и синтаксический сахар. В одной строке куча логики. Огромную массу работы сгрузить на Runtime. Приводят пример, что Haskell очень высокоуровневый язык с очень сложным Runtime-ом. И разработчики языка долго искали ошибку в Runtime из-за которых текла память.
11. Произнесли выражение - Оберон позволяет размещать struct на Стеке, а не в Неар.
   Произнесли выражение - в Java не поправили типизацию в сторону универсальных языков - всё живёт в Неар. Любой массив/struct - в Неар. Указательная семантика на объект. Нельзя работать так, чтобы не порождать мусор. В Си что массив, что struct можно разместить на стеке.
12. Python не может сам перемножать матрицы. Всё под капотом работает на lib-ах, написанных на Си или Fortran. Т.е. Python - это среда обращения к этим библиотекам.
13. Rust - всё затипизированно по максимуму. Всё обмазано типами.
14. Только наследование интерфейсов. Работать через композицию. Писал в 90-х Клеменс Шиперски.
15. Писать циклы без break. Только WHILE, на крайняк FOR.



Сейчас Web строится на Framework-ах. Мы пишем код под Framework, а Framework уже сам "компилирует" наш код в HTML/CSS/JS. Т.е. Framework - это как движок аля GTK+ или QT, который работает на стороне клиента/браузера.

Реактивное программирование - в императивном z=х+у посчитали z, далее изменили значение х, на z это никак не повлияло. В реактивном, как только изменили значение х или у, автоматически изменится значение z.

LISP - в основном задумывался для обработки больших списков.

Фаулер "Архитектура корпоративных приложений"
Эванс "Предметно-ориентированное проектирование" советует Илья Ермаков рассказывал про Оберон
Уоррена "Алгоритмические трюки для программистов"

Стек - оптимальное использование RAM. Heap снизу вверх, Стек сверху вниз - вероятно плохо эти области разделять на 2-а независимых адресных пространства.

Компонентно-ориентированное программирование:
http://www.oreilly.com/library/view/programming-net-components/0596102070/ch01s02.html
В С++ из 100 шт .срр после компиляции получаем одни .ехе-шник. Сделали изменения в одном .срр надо всё перелинковать. КОП ~ Java все исходники лежат в своих файлах, при необходимости load Module, при ненадобности unload. Между модулями нет никакой связи, никак не зависят друг от друга - упрощение в разработке. В ООП с наследованием надо чётко придерживаться иерархии классов. У каждого модуля есть Interface ~ header файл. В работающей программе можно выгрузить одну версию модуля и заменить ее на другую - без перекомпиляции и перезапуска.
2-а подхода: в нашем приложении создавать сложную иерархию классов через наследование/полиморфизм или делать независимые компоненты и всё связывать через Interface-ы.
Через Interface-ы это Black-box - пишем Module + Interface, Module компилируем в машинный код, тем самым скрывая внутренности = чёрный ящик.
Наследование это White-box - мы постоянно должны видеть внутренности родительских классов, чтобы понимать от чего наследуемся. Но плюсом является Полиморфизм.