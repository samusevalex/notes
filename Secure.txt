Для создания Self-Signed SSL Certificate необходимо 2-а действия:
	1. Сгенерировать пару Private-Public RSA Keys
	2. Фактически cоздание .txt файла соответствующего формату X.509 и добавления к нему Public ключа. Т.к. сертификат Self-Signed, то не берётся никаких Hash и т.п. чепухи.

Утилита openssl позволяет всё сделать за один заход:
# openssl req -x509 -newkey rsa:4096 -keyout key.pem -out cert.pem -nodes -subj '/CN=gitlab.local' -days 365
В папке получим 2-а файла: key.pem и cert.pem. Переносим эти файлы в папку /etc/gitlab/ssl. Теперь при заходе на https ругани не будет.

HTTP proxy проксируют только HTTP трафик.
SOCKS proxy проксируют Application level. В RFC пишут: создаём первое соединение - клиент отправляем команду CONNECT на IPsocks5:1080 + IPdc++:411 и соединяемся с dc++. Создаём второе соединение - на прокси сервер отправляем команду BIND, чтобы он сделал mapping входящих пакетов от dc++ к нам. Прокси сервер делает mapping и присылает ответ =ОК с Portfor_dc++. Далее мы используем эту инфу и по первому соединению отправляем запрос на dc++, мол входящие соединения шли сюда: IPsocks5:Portfor_dc++.

SOCKS5 = SOCKS4 + Secure (authentication methodologies, шифрование и т.п.)

TLS -  это ~ SSL version 3.

Прозрачные HTTP Proxy - не изменяют запросы и ответы. Анонимность не изменяется и сайты могут получить наш IP.
Анонимные HTTP Proxy - изменяют HTTP-заголовок, заменяют IP-адрес своим, добавляют дополнительные команды переадресации, чтобы сайт не узнал наш IP.

Diffie–Hellman.
Публично договариваемся, что p = 23 и g = 5.
Alice придумывает Secret Key "a" и генерирует A = ga mod p.
Bob придумывает Secret Key "b" и генерирует B = gb mod p.
Обмениваются значениями A и B.
Ab mod p = gab mod p = gba mod p = Ba mod p = key для симметричного шифрования.
Злодеи, зная p, g, A, B не могут вычислить Ab mod p или Ba mod p.

Правильно делать:
Root CA ->Policy CA -> Issuing CA
Root CA - можно выключать, он аутентифицирует Policy CA
Policy CA - может быть несколько. Если используются различные схемы проверки подлинности участников, которые запрашивают сертификаты и требования к ним, а так же мероприятия по организации CA
Issuing CA - выдаёт сертификат конечным потребителям: компьютерам, пользователям, сервисам.

	Кодировка DER = это ASN.1 - стандарт записи как TLV: тип, длина, значение.
	Coding BASE64 - всё кодируется 64 знаками: a..z A..Z 0..9 + 2 спец.символа (+ и /). Хорошо кодировать бинарую инфу в виде "текста". Есть ещё BASE32 - a..z 2..7 и = т.е. регистронезависимое,  исключены 0, который можно перепутать с О, 1-I и т.д. ~ в общем чтобы человек мог записать ручкой и не запутаться.


http://www.sysadmins.lv/blog-ru/certificate-chaining-engine-kak-eto-rabotaet.aspx
	Помимо системных хранилищ, сертификаты можно хранить в файлах. Файлы с расширением .CER .CRT .DER содержат сертификат без Private ключа в кодировке DER и BASE64. Если нужен Private key, рядом с таким сертификатом хранится файл .PVK защищённый паролем (3DES/AES). Для хранения цепочки файлов без Private ключей .P7B (стандарт PKCS#7). Для хранения цепочки сертификатов + Private key -> .P12 или .PFX (стандарт PKCS#12). Private ключ так же защищается паролем.

PKCS#7 - Cryptographic Message Syntax (CMS) без Private keys как правило в формате DER. Может быть подписан несколькими сторонами, т.е. в CMS сообщении несколько блоков SignerInfo.
PKCS#10 - Определяет формат для запроса сертификата, когда у роутера нет доступа к СА. Сначала генерили "нечто" на роутере (текст в BASE64) = запрос. Заходили на CA. Кликали "Отправить запрос". Вставляли текст с роутера. Потом где-то в винде делали Apply. Скачивали сертификат. Загружали в роутер.
PKCS#12 - Контейнер для одного или нескольких сертификатов с Private ключами. Когда в Windows хотим сделать export Private ключа, то получаем файл .PFX в формате PKCS#12. Защищён паролем. Пароль используется в связке с 3DES.


Прикреплённая подпись - .doc файл можно прочитать только с использованием спец.программ.
Detached Signature (откреплённая подпись) - рядом с .doc создаётся новый файл .sig или .sgn

			Сертификат X.509
Version: 3
Serial Number: 00:ED:1C:AB:69:49:3D:96:49
Действителен с: Wed, 16 Nov 2022 00:00:00 GMT
Действителен до: Tue, 31 Oct 2023 23:59:59 GMT
Subject DN: CN=www.example.com				Кому выдан
Issuer DN: CN=DigiCert TLS					Кто выдал
Алгоритм Public Key: RSA
Public Key: 30:48:02:41:00:9b:...
Алгоритм Hash: SHA
Hash, зашифрованный Private ключом Issuer DN: 30:65:02:30:...
	Мы скачиваем DigiCert TLS сертификат, его Public Key расшифровываем эту последовательность и получаем Hash, который должен быть = Hash сертификата, который мы можем вычислить сами

+ в сертификате может быть указана дополнительная информация:

CRL (Certificate Revocation List) бывает
	1. Base CRL - полный список CRL. Серийные номера отозванных сертификатов + причина отзыва.
	2. Delta CRL - инкрементальный. Список CRL, в который включаются только сертификаты, которые были отозваны с момента последней публикации Base CRL.
OCSP (Online Certificate Status Protocol) - в Online проверяем отозван сертификат или нет.
CDP (CRL Distribution Points) - где можно скачать CRL.

Certificate Chaining Engine - в цепочке сертификатов надо доверять как минимум самому первому, например VeriSign. Его ручками добавляем в секцию Trusted Root CA. Сама цепочка может быть построена разными способами.
	1.Authority Info Access (AIA) - мы не у себя держим вышеподписанный сертификат, а храним только URL
		Access Method=Certification Authority Issuer (1.3.6.1.5.5.7.48.2)
		Alternative Name:
			URL=http://www.microsoft.com/pki/mscorp/Microsoft Secure Server Authority.crt
	2. Храним всю цепочку у себя в PKCS#7 формате.


TOR - скрывает клиента, для похода на публичный сайт. Необходимо установить браузер c TOR-ом.

.onion -> .tor2web.to		в поисковике вбить tor2web
.onion -> .onion.ly
.i2p -> .i2phides.me
.i2p -> .i2p.mk16.de		см. http://i2p-inproxy.mk16.de

I2P - скрывает сайт для похода "публичного" клиента. Устанавливаем клиент, запускаем. В браузере в качестве прокси прописываем 127.0.0.1:4445 и ходим по сайтам zzz.i2c
apt install i2p
отредактировать /home/user/.i2p/i2ptunnel.config (например, 127.0.0.1 заменить на 192.168.1.150)
i2prouter start/stop/restart и подождать пару минут пока сервис поднимится. В netstat -an должно появиться LISTEN 127.0.0.1:4444

IP Source Guard - технология, которая разрешает отправку пакетов только с IP адресов, которые выданы DHCP. СВИТЧ на конкретный порт вешает соответствующий ACL.
no ip source-route - команда выключает возможность маршрутизации по SrcIP. Как-то можно в IP пакете сделать так, чтобы маршрутизация была по SrcIP
uRFP - unicast reverse path forwarding используется на уровне Access. Если пакет c SrcIP = 10.0.0.1 пришёл на некий интерфейс, а в таблице маршрутизации сеть 10.0.0.0 находится за другим интерфейсом, то пакет дропается.
ARP inspection - на основании выданного DHCP адреса СВИТЧ ! не позволяет с данного порта принимать какие-либо другие ARP пакеты.